###node第一天（第十周周六）

@(第十周)

###安装须知
安装选项
![Alt text](./QQ图片20170318100919.png)

###查看版本git --version
运行ls 成功即可

![Alt text](./1489803335294.png)

###查看账户

git config --list
```
解决
git config --global user.name liukaijiedegit
git config --global user.email Lkj705463808x
```




## 1.git
安装brew在mac上
mac http://brew.sh
```
brew install git 
```
### 1.1 告诉git你是谁
```
git config --global user.name xxxxx
git config --global user.email xxxxx
git config --list
```
### 1.2 初始化git
```
git init
```
## 清除当前

```
clear
```
## 新建文件夹

```
mkdir ####
```
##进入子文件

```
cd 文件名
cd lkj/
```
##文件夹子目录的详悉信息

```
ls -l
ls -al 全部目录（包含隐藏文件）
```

## 创建并进入目录 
```
mkdir gitTest && cd gitTest
```

## ls显示所有文件
```
ls -al 显示隐藏的
```

## 创建文件
```
touch index.txt	
cat index.txt 查看内容
rm index.txt   删除文件

```

## 查看git状态
```
git status 
```

## 添加到暂存区
```
	git add .
```

## 提交到历史库
```
git commit -m 'write hello world'
```
### 对比代码
工作区和暂存区
```
git diff
```
暂存区和历史区 
```
git diff --cached
```
工作区和历史区 
```
git diff master(分支名)
```
## vi编辑
```
vi index.txt
i 编辑模式
esc + :wq 保存并退出    
强制退出q!

备注“打开编辑的时候，默认在倒数第二个字母。，解决按I键，再按方向键右键”
```
##文件送暂存区下载到工作区（）

```
git chechout 文件名
git chechout index.txt
```
##查看所有版本号
git reflog  
##查看日志
git log   过多可以使用上下键查看，不想看可以q退出
git log --graph
 git log --graph --oneline


##返回到历史版本（历史库下载）
 git reset --hard 版本号  
 git reset --hard c75ddd9 
 ------------------------------------------------------------------------------------------
-------------------------------------------------
##分支管理

```
创建分区
git branch  名字
查看分区
git branch 

```
##切换分支
	
```
git checkout dev（切换分区）
git checkout  -b dev（创建并进入分区）
```	

##删除分支

```
git branch  -d  dev
```

git log --grep==me

合并俩个分支
(在master上面合并dev)(你认为那个是主的就进入那个分区合并另外哪一个)
```
git merge dev
- 产生冲突(手动解决提交新的版本)俩个分区中如有同样名字的文件，单内容有所不同，
```
-----------------------------------------------------------------------------------------
-------------------------------------------



##新建仓库的方式
![Alt text](./1489822154808.png)

![Alt text](./1489822119109.png)

##提交
![Alt text](./1489827578944.png)
![Alt text](./1489827627172.png)

git add. 
git  commit -m """

git push origin  (分区)         推送到库里

 git remote add origin 地址   添加远程仓库
 
##发布静态页
-发布的静态页必须在gh-pages分支

git checkout -b gh-pages

git add . 

git commit -m

git push origin gh-pages
、------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------
组员需要
新建文件git clone  对应组长发来的GIT库路径
然后执行git pull 更新其他组员的文件，以防文件流失
git  add .      保存到暂存区
git commit -m      保存到历史区

git push origin master  更新组长库里的数据

------------------------------------------------------------------------
------------------------------------------------------------------------
组长需要
git pull       下载更（组长先下载其他组员的文件，更新本地数据）
git  add .      保存到暂存区
git commit -m      保存到历史区
git remote add  **(连接名，自己定义)  家地址https://github.com/zhufengzhufeng/201615node.git       关联老师的git  库地址
 git status                     查看状态
 git pull   **(连接名，自己定义) master            更新老师的文件
 如本机有修改               
（ git  ddd . 
git commit -m
git push origin master
）
如本机没有修改
git push origin master


----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------
##rm -rf  文件夹 删除文件夹


![Alt text](./1489844645232.png)



















![Alt text](./1489840285913.png)
















![Alt text](./1489839826831.png)





















![Alt text](./1489839855432.png)
















![Alt text](./1489840300983.png)














![Alt text](./1489844540618.png)













![Alt text](./1489840676359.png)![Alt text](./1489841348545.png)
















![Alt text](./1489840702580.png)
























![Alt text](./1489841105314.png)















![Alt text](./1489841441149.png)
















![Alt text](./1489841149392.png)




















![Alt text](./1489841524812.png)


















### node 第二天（第十周周日）










###配置环境



![Alt text](./1489888554010.png)









![Alt text](./1489889728088.png)
）
## 单线程和多线程
- node主线程是单线程的，进程中包含线程，正常java 一个进程中包含多个线程，node中一个进程只能包含一个线程，允许开子进程。

## 阻塞和非阻塞
- 针对内核来说的，非阻塞是异步的前置条件

## 回调（回头再调）
- 用回调来解决异步编程问题

## 事件环

## 异步的文件读写，callback,定时器，能用异步 不用同步

## node全局对象
- 在任意地点可以直接访问的
- 在global上挂载的都是全局对象

###同步和异步
- 代码从上到下执行，先执行同步，再走异步（在同步异步同事存在的情况），异步不会阻塞主线

         同步：当前这次数据如果没有请求成功，其他事情都不能做，
         异步：当前这次数据如果没有请求成功，我们也可以继续去做其他的事情


    ----------------------------------------------
一．进程同步及异步的概念 
         1．进程同步：就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事.就像早上起床后,先洗涮,然后才能吃饭,不能在洗涮没有完成时,就开始吃饭.按照这个定义，其实绝大多数函数都是同步调用（例如sin,isdigit等）。但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。最常见的例子就是 
sendmessage。该函数发送一个消息给某个窗口，在对方处理完消息之前，这个函数不返回。当对方处理完毕以后，该函数才把消息处理函数所返回的lresult值返回给调用者。 
2．异步 
异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。 
以casycsocket类为例（注意，csocket从casyncsocket派生，但是其功能已经由异步转化为同步），当一个客户端通过调用connect函数发出一个连接请求后，调用者线程立刻可以朝下运行。当连接真正建立起来以后，socket底层会发送一个消息通知该对象。 
这里提到执行部件和调用者通过三种途径返回结果：状态、通知和回调。可以使用哪一种依赖于执行部件的实现，除非执行部件提供多种选择，否则不受调用者控制。如果执行部件用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循环去检查某个变量的值，这其实是一种很严重的错误）。如果是使用通知的方式，效率则很高，因为执行部件几乎不需要做额外的操作。至于回调函数，其实和通知没太多区别。 
进程同步的基本概念 
在计算机系统中，由于资源有限而导致了进程之间的资源竞争和共享，因此，进程的并发执行不仅仅是用户程序的执行开始时间的随机性和提高资源利用率的结果，也是资源有限性导致资源的竞争与共享对进程的执行过程进行制约所造成的。那么，在进程的并发执行过程中存在哪些制约呢？ 
二．同步与异步传输： 
-  1.异步传输 
通常，异步传输是以字符为传输单位，每个字符都要附加 1 位起始位和 1 位停止位，以标记一个字符的开始和结束，并以此实现数据传输同步。所谓异步传输是指字符与字符(一个字符结束到下一个字符开始)之间的时间间隔是可变的，并不需要严格地限制它们的时间关系。起始位对应于二进制值 0，以低电平表示，占用 1 位宽度。停止位对应于二进制值 1，以高电平表示，占用 1~2 位宽度。一个字符占用 5~8位，具体取决于数据所采用的字符集。例如，电报码字符为 5 位、ASCII码字符为 7 位、汉字码则为8 位。此外，还要附加 1 位奇偶校验位，可以选择奇校验或偶校验方式对该字符实施简单的差错控制。发送端与接收端除了采用相同的数据格式(字符的位数、停止位的位数、有无校验位及校验方式等)外，还应当采用相同的传输速率。典型的速率有：9 600 b/s、19.2kb/s、56kb/s等。 
异步传输又称为起止式异步通信方式，其优点是简单、可靠，适用于面向字符的、低速的异步通信场合。例如，计算机与Modem之间的通信就是采用这种方式。它的缺点是通信开销大，每传输一个字符都要额外附加2～3位，通信效率比较低。例如，在使用Modem上网时，普遍感觉速度很慢，除了传输速率低之外，与通信开销大、通信效率低也密切相关。 
-  2 . 同步传输 
通常，同步传输是以数据块为传输单位。每个数据块的头部和尾部都要附加一个特殊的字符或比特序列，标记一个数据块的开始和结束，一般还要附加一个校验序列 (如16位或32位CRC校验码)，以便对数据块进行差错控制。所谓同步传输是指数据块与数据块之间的时间间隔是固定的，必须严格地规定它们的时间关系。 
三．同步阻塞与异步阻塞： 
同步是阻塞模式，异步是非阻塞模式。  
我的理解：同步是指两个线程的运行是相关的，其中一个线程要阻塞等待另外一个线程的运行。异步的意思是两个线程毫无相关，自己运行自己的。  
同步是指：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。  
异步是指：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。  
举个不太恰当的例子,就像:  
SendMessage(...)  
TRACE0("just  like  send");  
PostMessage(...)  
TRACE0("just  like  WSASend  using  overlapped");  
 SendMessage是调用的时候不返回,等消息响应后才执行TRACE0,这就是同步.  
PostMessage是调用后马上返回,不用消息响应就执行TRACE0,这就是异步. 
四．其它解释： 
 同步和异步的区别 
 举个例子：普通B/S模式（同步）AJAX技术（异步） 
同步：提交请求->等待服务器处理->处理完毕返回 这个期间客户端浏览器不能干任何事 
异步: 请求通过事件触发->服务器处理（这是浏览器仍然可以作其他事情）->处理完毕 
同步就是你叫我去吃饭，我听到了就和你去吃饭；如果没有听到，你就不停的叫，直到我告诉你听到了，才一起去吃饭。 
异步就是你叫我，然后自己去吃饭，我得到消息后可能立即走，也可能等到下班才去吃饭。 
所以，要我请你吃饭就用同步的方法，要请我吃饭就用异步的方法，这样你可以省钱。 
举个例子 打电话时同步 发消息是异步
     

	- 五个人一起吃饭（对于饭是异步）
 ###  阻塞和非阻塞
 ![Alt text](./1489897175835.png)
	
- 针对内核来说的，非阻塞是异步的前置条件

### 回调（回头再调）


```
 function read(callback) {
    setTimeout(function () {
        var data = 'hello world';
    },2000);
}
//解决异步编程问题
read(function (data) {
    console.log(data);
});
```

- 用回调来解决异步编程问题

### 事件环
![Alt text](./1489897237503.png)


### 异步的文件读写，callback,定时器，能用异步 不用同步







###  node全局对象
![Alt text](./1489897277661.png)

- 在任意地点可以直接访问的
- 在global上挂载的都是全局对象
 
--------------------------------------------------------------------------



内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系；
耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。


##模块
#### JS中的模块
- （seajs cmd, requirejs amd, node commonjs）
- cmd 就近依赖，amd 依赖前置
- 单例（不可能保证完全解决冲突）
- 闭包，node中实现模块化  采用的是读写（读写会生成一个闭包就是一个函数）
 
 
#### commonjs
 - 如何定义模块
 - 如何导出一个模块
 - 如何使用一个模块
 

--------------------------------------------------------------------------------------------------------
-----------------------------------------------------------


## npm node-package-manager
### 全局下载(在命令行下使用) -g
### 安装nrm源切换工具
```
npm i nrm -g
```
### 增加珠峰源
```
nrm ls
nrm add zf http://172.18.1.139
nrm use zf
```
### 安装全局
https://github.com/ksky521/nodePPT
```
npm install nodeppt -g
```
### http-server
```
npm install http-server -g
```
启动服务
```
http-server -p 3000 更改端口
```
### 卸载
```
npm uninstall http-server -g
```

### 本地安装(在我们代码里使用的)
#### 初始化依赖文件(package.json)
在指定目录下生成
```
npm init -y
```
#### 1.开发依赖 gulp

```
npm install gulp (--save-dev)或者(-D)
```

#### 2.项目依赖 jquery
查看版本
```
npm info jquery
npm install jquery@2.2.4 (--save)或者(-S)
```

#### 3.发布自己的包
- package.json 
    - name不能和已发布的包重名
    - main里对应的主文件件写一个
- 发布要切换到npm  
- 添加用户 有的话可以登录
```
npm addUser
```
- 发布
```
npm publish 
```
- 卸载包
```
npm unpublish  --force
```

## 模块的查找机制

> 为什么-g安装的可以在命令行下使用,npm可以在命令行下使用，所有的全局包 都安装在npm上，会在npm下创建一个脚本文件，可以映射到真实的文件上，所以通过全局安装的可以直接在命令行下使用

## bower(管理前端文件的) 
npm(管理node模块的) ->安装的文件放到node_modules下 不能指定安装目录
bower(管理前端文件的) ->制定目录下载 只管理前端文件(在git中下载)
```
npm install bower -g
```
### 1.1初始化 bower.json记录依赖
```
bower init
```
### 1.2下载文件
```
bower install bootstrap --save
```
### 1.3 指定目录
```
.bowerrc
{"directory":"src/public/lic"}
```


> 默认安装到bower_component下

### 发布hexo
```
npm install hexo-cli -g
```

### 生成blog
```
hexo init
```

### 启动服务
```
hexo server
```

### 文章放在_posts下
md格式文件

### 仓库名
```
github名.github.io
```

### 发布到git上需要下载一个插件 
```
npm install hexo-deployer-git --save
```

### 配置_config.yml
```
deploy:
  type: git
  repo: https://username:password@github.com/zuyuan/zuyuan.github.io.git
  branch: master
  message: push
```

## 如果重新提交
### 生成
```
hexo g
```

### 发布
```
hexo deploy
```

### 访问网址
```
zuyuan.github.io
```
 


 















































































































































